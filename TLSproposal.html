<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=us-ascii">
<title>Skeleton Proposal for Thread-Local Storage (TLS)</title>
</head>
<body>
<h1>Skeleton Proposal for Thread-Local Storage (TLS)</h1>

<p>
ISO/IEC JTC1 SC22 WG21 Pnnnn - 2015-09-23
</p>

<p>
Paul E. McKenney, paulmck@linux.vnet.ibm.com<br>
JF Bastien, jfb@google.com<br>
TBD
</p>

<h2>Introduction</h2>

<p>
This document in a follow-on to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4376.html">N4376</a>,
and provides an initial description of a potential solution to the TLS
problem statement implied by that document.

<h2>Summary of Problem Statement</h2>

<p>
TLS is a problem for same-instruction-multiple-data (SIMD) units
and general-purpose graphical processing units (GPGPUs)
because large programs can have very large amounts of TLS data,
each item of which might have C++ constructors and destructors.
Spending many milliseconds to run constructors and destructors
for a SIMD computation that only takes a few microseconds to run
is clearly not a reasonably way to achieve high performance.

<p>
GPGPU code often has longer runtimes, but they also tend to run
extremely large numbers of threads, adding a memory-footprint
problem to the constructor-destructor overhead problem.
To make matters worse, in some environments, the constructors and
destructors must be run on heavyweight CPUs rather than on the
lightweight GPGPU hardware threads, which severely restricts the
computational resources that can be applied to run constructors
and destructors for GPGPU TLS data.

<p>
We expect that other types of executors will also have problems
with TLS as currently envisioned and implemented.
For example, some types of executors nest hierarchically, so that
a number of light-weight executors might run in the context of
a heavy-weight <tt>std::thread</tt>.
If a given function accesses TLS, and is called both from the context
of a <tt>std::thread</tt> and from the context of a task executing
within an <tt>std::thread</tt>, what should its TLS accesses do?
If the instances invoked from a task access task-level TLS data,
the function must do different things when invoked in different contexts.
If the <tt>std::thread</tt>-level TLS data is accesses, then the
task-level accesses might introduce data races and thus undefined behavior.

<h2>Tentative Goals</h2>

<p>
There are a number of possible ways of resolving this issue, as discussed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4376.html">N4376</a>,
however, this paper focuses on the possibility that TLS is an optional
component of an executor.
With this approach, <tt>std::thread</tt> implements TLS, but lighter-weight
executors might choose not to.

<p>
For this approach, we put forward the following tentative goals:

<ol>
<li>	Make TLS availability optional for light-weight executors,
	as noted above.
	<ol type="alpha">
	<li>	Modify the standard library so as to minimize the
		number of standard library functions that are
		prohibited from within TLS-free executors.
	<li>	Maintain the performance and scalability of high-quality
		standard-library implementations.
	</ol>
<li>	Avoid source-code changes for existing code running in
	existing executors (such as <tt>std::thread</tt>) that
	provide TLS.
<li>	Avoid the need to recompile existing code running in
	existing executors (such as <tt>std::thread</tt>) that
	provide TLS.
<li>	Avoid API changes in the standard library.
	(C++ only, as it seems quite unlikely that this goal can be
	achieved in C.)
<li>	Recruit sanitizer developers to help identify issues in
	new code and in standard-library code related to this change.
</ol>

<p>
The next section exercises these goals by attempting to apply them
to the TLS <tt>errno</tt> facility as used by the standard math library,
in the hope of sparking productive discussion.

<h2>The Curious Case of <tt>errno</tt> and the Standard Math Library</h2>

<p>
C++ provides a per-<tt>std::thread</tt> facility named
<tt>errno</tt> (19.4) in order to provide POSIX compatibility.
This is also required to allow C++'s standard math library (26)
maintain compatibility with that of C.
Section 7.12 of the C standard specifies that if
<tt>math_errhandling &amp; MATH_ERRNO</tt> is non-zero, indication of
certain errors are available via <tt>errno</tt>.
Furthermore, Section 19.4 of the C++ standard specifies that
<tt>errno</tt> is provided on a per-thread basis.
Therefore, <tt>errno</tt> is frequently implemented using TLS,
which in turn means that the math library's use of <tt>errno</tt>
forms an excellent initial test case for changes to TLS.

<p>
One approach is to require that
<tt>math_errhandling &amp; MATH_ERREXCEPT</tt> be non-zero and that
<tt>math_errhandling &amp; MATH_ERRNO</tt> be zero in all cases where
math library functions are invoked from executors that do not provide TLS.
However, this approach cannot be used in conjunction with existing code
that invokes math functions and tests <tt>errno</tt>.
This could in turn be dealt with by forbidding use of code
that checks for math errors using <tt>errno</tt>, but this would have
the undesirable effect of acting as a barrier to the adoption of
light-weight executors.

<p>
Another approach is to use function overloading, so that an additional
<tt>double sqrt(double, int *)</tt> declaration could be used in
light-weight executors.
Note that in some implemnetations this could require modifying the
underlying C library in order to bypass <tt>errno</tt> setting.
Code invoked both from light-weight and heavy-weight executors would
need to use the new delaration, but code invoked only from
heavy-weight executors could continue using the old API, consistent
with the goals preserving existing source and binary code.
It is tempting to instead overload on the return value, but C++
of course does not support this notion.
A (probably partial) list of new APIs is as follows:

<ul>
<li>	double acos(double x, int *errnm);
<li>	float acosf(float x, int *errnm);
<li>	long double acosl(long double x, int *errnm);
<li>	double asin(double x, int *errnm);
<li>	float asinf(float x, int *errnm);
<li>	long double asinl(long double x, int *errnm);
<li>	double atan2(double y, double x, int *errnm);
<li>	float atan2f(float y, float x, int *errnm);
<li>	long double atan2l(long double y, long double x, int *errnm);
<li>	double acosh(double xint *errnm);
<li>	float acoshf(float xint *errnm);
<li>	long double acoshl(long double xint *errnm);
<li>	double atanh(double xint *errnm);
<li>	float atanhf(float xint *errnm);
<li>	long double atanhl(long double xint *errnm);
<li>	double cosh(double xint *errnm);
<li>	float coshf(float xint *errnm);
<li>	long double coshl(long double xint *errnm);
<li>	double sinh(double xint *errnm);
<li>	float sinhf(float xint *errnm);
<li>	long double sinhl(long double xint *errnm);
<li>	double exp(double xint *errnm);
<li>	float expf(float xint *errnm);
<li>	long double expl(long double xint *errnm);
<li>	double exp2(double xint *errnm);
<li>	float exp2f(float xint *errnm);
<li>	long double exp2l(long double xint *errnm);
<li>	double expm1(double xint *errnm);
<li>	float expm1f(float xint *errnm);
<li>	long double expm1l(long double xint *errnm);
<li>	int ilogb(double xint *errnm);
<li>	int ilogbf(float xint *errnm);
<li>	int ilogbl(long double xint *errnm);
<li>	double log(double xint *errnm);
<li>	float logf(float xint *errnm);
<li>	long double logl(long double xint *errnm);
<li>	double log10(double xint *errnm);
<li>	float log10f(float xint *errnm);
<li>	long double log10l(long double xint *errnm);
<li>	double log1p(double xint *errnm);
<li>	float log1pf(float xint *errnm);
<li>	long double log1pl(long double xint *errnm);
<li>	double log2(double xint *errnm);
<li>	float log2f(float xint *errnm);
<li>	long double log2l(long double xint *errnm);
<li>	double logb(double xint *errnm);
<li>	float logbf(float xint *errnm);
<li>	long double logbl(long double xint *errnm);
<li>	double scalbn(double x, int nint *errnm);
<li>	float scalbnf(float x, int nint *errnm);
<li>	long double scalbnl(long double x, int nint *errnm);
<li>	double scalbln(double x, long int nint *errnm);
<li>	float scalblnf(float x, long int nint *errnm);
<li>	long double scalblnl(long double x, long int nint *errnm);
<li>	double hypot(double x, double yint *errnm);
<li>	float hypotf(float x, float yint *errnm);
<li>	long double hypotl(long double x, long double yint *errnm);
<li>	double pow(double x, double yint *errnm);
<li>	float powf(float x, float yint *errnm);
<li>	long double powl(long double x, long double yint *errnm);
<li>	double sqrt(double xint *errnm);
<li>	float sqrtf(float xint *errnm);
<li>	long double sqrtl(long double xint *errnm);
<li>	double erfc(double xint *errnm);
<li>	float erfcf(float xint *errnm);
<li>	long double erfcl(long double xint *errnm);
<li>	double lgamma(double xint *errnm);
<li>	float lgammaf(float xint *errnm);
<li>	long double lgammal(long double xint *errnm);
<li>	double tgamma(double xint *errnm);
<li>	float tgammaf(float xint *errnm);
<li>	long double tgammal(long double xint *errnm);
<li>	long int lrint(double xint *errnm);
<li>	long int lrintf(float xint *errnm);
<li>	long int lrintl(long double xint *errnm);
<li>	long long int llrint(double xint *errnm);
<li>	long long int llrintf(float xint *errnm);
<li>	long long int llrintl(long double xint *errnm);
<li>	long int lround(double xint *errnm);
<li>	long int lroundf(float xint *errnm);
<li>	long int lroundl(long double xint *errnm);
<li>	long long int llround(double xint *errnm);
<li>	long long int llroundf(float xint *errnm);
<li>	long long int llroundl(long double xint *errnm);
<li>	double fmod(double x, double yint *errnm);
<li>	float fmodf(float x, float yint *errnm);
<li>	long double fmodl(long double x, long double yint *errnm);
<li>	double remainder(double x, double yint *errnm);
<li>	float remainderf(float x, float yint *errnm);
<li>	long double remainderl(long double x, long double yint *errnm);
<li>	double remquo(double x, double y, int *quoint *errnm);
<li>	float remquof(float x, float y, int *quoint *errnm);
<li>	long double remquol(long double x, long double y, int *quoint *errnm);
<li>	double nextafter(double x, double yint *errnm);
<li>	float nextafterf(float x, float yint *errnm);
<li>	long double nextafterl(long double x, long double yint *errnm);
<li>	double fdim(double x, double yint *errnm);
<li>	float fdimf(float x, float yint *errnm);
<li>	long double fdiml(long double x, long double yint *errnm);
<li>	double fma(double x, double y, double zint *errnm);
<li>	float fmaf(float x, float y, float zint *errnm);
<li>	long double fmal(long double x, long double y, long double zint *errnm);
</ul>

<h2>Summary</h2>

<p>
This document has examined some ways to permit light-weight executors
to avoid implementing TLS.
Your ideas are more than welcome!


<h2>Acknowledgements</h2>

<p>
@@@

</body></html>
